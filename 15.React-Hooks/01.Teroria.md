# âš›ï¸ React Hooks: `useState` y `useEffect`

React Hooks son funciones que permiten usar el estado y otras caracterÃ­sticas de React en **componentes funcionales**. Fueron introducidos en React 16.8 y cambiaron el juego. ğŸ®

En este README veremos dos de los hooks mÃ¡s fundamentales: `useState` y `useEffect`.

## ğŸ” `useState`

`useState` nos permite agregar estado a un componente funcional.

### ğŸ§  Â¿CÃ³mo funciona?

```jsx
import { useState } from 'react';

function Contador() {
  const [contador, setContador] = useState(0);

  return (
    <div>
      <p>Contador: {contador}</p>
      <button onClick={() => setContador(contador + 1)}>Sumar</button>
    </div>
  );
}
```

### ğŸ§© ExplicaciÃ³n

- `useState(0)` â†’ el `0` es el **valor inicial**.
- `contador` â†’ **valor actual** del estado.
- `setContador` â†’ **funciÃ³n para actualizar** ese valor.

> Cada vez que llamÃ¡s a `setContador`, React vuelve a renderizar el componente con el nuevo valor. ğŸ”„

## ğŸŒ `useEffect`

Sirve para manejar **efectos secundarios**: tareas que ocurren fuera del flujo de renderizado, como llamadas a APIs, timers o manipulaciÃ³n del DOM.


### ğŸ§  Â¿CÃ³mo funciona?

```jsx
import { useState, useEffect } from 'react';

function Ejemplo() {
  const [nombre, setNombre] = useState('Ceci');

  useEffect(() => {
    console.log(`El nombre cambiÃ³ a: ${nombre}`);
  }, [nombre]);

  return (
    <input 
      value={nombre} 
      onChange={(e) => setNombre(e.target.value)} 
    />
  );
}
```

### ğŸ§© ExplicaciÃ³n

- El cÃ³digo dentro de `useEffect` se ejecuta **despuÃ©s** de que el componente se renderiza.
- El segundo parÃ¡metro (`[nombre]`) es un **array de dependencias**:
  - Si `nombre` cambia, el efecto se vuelve a ejecutar.
  - Si lo dejÃ¡s vacÃ­o `[]`, se ejecuta **una sola vez**, al montar el componente (como `componentDidMount`).
  - Si **no lo pasÃ¡s**, se ejecuta en **cada render**. âš ï¸ *(No recomendado, puede afectar el rendimiento).*


### âš ï¸ Cuidados

- âŒ **No** pongas `useState` o `useEffect` dentro de condicionales o bucles.
- âœ… Usalos siempre en el **nivel superior** del componente.
- ğŸ§¨ **EvitÃ¡ efectos infinitos**: si olvidÃ¡s el array de dependencias, el efecto se ejecuta sin parar y puede congelar la app.


## âœ… Casos de uso comunes

| Hook        | Usos comunes                                                      |
|-------------|-------------------------------------------------------------------|
| `useState`  | Formularios, toggles, contadores, almacenar datos temporales      |
| `useEffect` | Fetch a APIs, suscripciones, timers, sincronizaciÃ³n de datos      |


## ğŸ§ª Bonus: `useEffect` para hacer fetch de datos

```jsx
import { useState, useEffect } from 'react';

function Usuarios() {
  const [usuarios, setUsuarios] = useState([]);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(res => res.json())
      .then(data => setUsuarios(data));
  }, []);

  return (
    <ul>
      {usuarios.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### ğŸ§  Resumen

- `useState` â†’ te da **estado** dentro de componentes funcionales.
- `useEffect` â†’ te permite manejar **efectos secundarios** (como `componentDidMount`, `componentDidUpdate` y `componentWillUnmount` juntos).


> ğŸ“Œ *Los hooks simplifican el cÃ³digo, lo hacen mÃ¡s limpio y evitan el uso de clases innecesarias. Aprenderlos bien te da superpoderes como dev.* ğŸš€
