# ğŸ® Tic Tac Toe con React y `useState`

Este proyecto es una guÃ­a paso a paso para crear el clÃ¡sico **Tres en LÃ­nea** usando Ãºnicamente **React** y el hook `useState`. Sin Redux, sin librerÃ­as externas. Solo React puro y simple. ğŸ§¼


## ğŸ§  Objetivo

Crear un juego de 3 en lÃ­nea con:

- âœ”ï¸ Un tablero 3x3.
- âœ”ï¸ Turnos alternados entre `X` y `O`.
- âœ”ï¸ DetecciÃ³n de ganador o empate.
- âœ”ï¸ BotÃ³n para reiniciar el juego.


## ğŸ§© Conceptos clave

- `useState`: Para manejar el estado del tablero, el turno y el resultado.
- Props: Si dividÃ­s la UI en componentes.
- Eventos: Para manejar clics en las celdas.


## ğŸ› ï¸ Estructura del estado

```jsx
const [board, setBoard] = useState(Array(9).fill(""));
const [turn, setTurn] = useState("X");
const [winner, setWinner] = useState(null);
```

## ğŸ“¦ Estructura sugerida

PodÃ©s hacerlo en un solo componente o separarlo para mantener el cÃ³digo mÃ¡s organizado:

- `<Game />`: Componente principal que maneja el estado del juego.
- `<Board />`: Renderiza las 9 celdas del tablero.
- `<Square />`: Representa una sola celda (casilla) del tablero.

> ğŸ§¼ Pero si querÃ©s mantenerlo simple usando solo `useState`, podÃ©s manejar todo dentro de **un solo componente** sin problema.

## ğŸ¯ Paso a paso

### 1. Renderizar el tablero

UsÃ¡ `map()` sobre el array `board` para crear las 9 celdas:

```jsx
board.map((value, index) => (
  <button onClick={() => handleClick(index)}>{value}</button>
))
```

### 2. Manejar clic en una celda

Cuando el usuario hace clic en una celda vacÃ­a, se marca con el sÃ­mbolo actual (`"X"` o `"O"`), se actualiza el tablero y se cambia el turno:

```jsx
const handleClick = (index) => {
  if (board[index] !== "" || winner) return;

  const newBoard = [...board];
  newBoard[index] = turn;
  setBoard(newBoard);

  const result = checkWinner(newBoard);
  if (result) {
    setWinner(result);
  } else {
    setTurn(turn === "X" ? "O" : "X");
  }
};
```

### 3. Verificar si alguien ganÃ³

Para detectar un ganador, se comparan combinaciones posibles en el tablero (filas, columnas y diagonales):

```jsx
const WIN_COMBINATIONS = [
  [0, 1, 2], [3, 4, 5], [6, 7, 8], // Filas
  [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columnas
  [0, 4, 8], [2, 4, 6]             // Diagonales
];

const checkWinner = (board) => {
  for (let combo of WIN_COMBINATIONS) {
    const [a, b, c] = combo;
    if (
      board[a] &&
      board[a] === board[b] &&
      board[a] === board[c]
    ) {
      return board[a]; // 'X' o 'O'
    }
  }

  // Si no hay ganador y todas las casillas estÃ¡n llenas, es empate
  if (board.every(cell => cell !== "")) {
    return "Empate";
  }

  return null;
};
```

### 4. Mostrar el resultado

Una vez que hay un ganador o un empate, podÃ©s mostrar un mensaje en pantalla:

```jsx
{winner && (
  <div>
    {winner === "Empate" ? "Empate ğŸ˜…" : `GanÃ³ ${winner} ğŸ‰`}
  </div>
)}
```

### 5. Reiniciar juego

Para reiniciar el juego, se limpia el estado del tablero, se restablece el turno a `"X"` y se borra el ganador:

```jsx
const resetGame = () => {
  setBoard(Array(9).fill(""));
  setTurn("X");
  setWinner(null);
};
```
BotÃ³n para ejecutar el reinicio:
```jsx
<button onClick={resetGame}>Reiniciar</button>
```
ğŸ§¼ Este botÃ³n es Ãºtil para jugar mÃºltiples partidas sin recargar la pÃ¡gina.

## âœ… Resumen del flujo

1. Se dibuja el tablero.
2. El jugador hace clic en una celda vacÃ­a.
3. Se coloca el sÃ­mbolo correspondiente (`X` o `O`).
4. Se verifica si hay un ganador o empate.
5. Se actualiza el turno o se muestra el resultado final.
6. El jugador puede reiniciar la partida con un botÃ³n.

## ğŸ“Œ Tips finales

- âŒ No modifiques el estado directamente. UsÃ¡ `setBoard([...board])`.
- âš ï¸ No necesitÃ¡s `useEffect` para este ejemplo.
- ğŸ§  Es un gran ejercicio para practicar `useState`, lÃ³gica condicional y renderizado dinÃ¡mico.

> ğŸš€ *Tic Tac Toe* es un ejemplo clÃ¡sico para aprender el manejo de estado en React. Una vez dominado, Â¡estÃ¡s lista para juegos mÃ¡s complejos o apps interactivas!
